# printj

Extended `sprintf` implementation (for the browser and nodejs).  Emphasis on
compliance, performance and IE6+ support.

```js
PRINTJ.sprintf("Hello %s!", "World");
```

A self-contained specification of the printf format string is included below in [this README](#printf-format-string-specification), as well as a summary of the
[support against various printf implementations](#support-summary)


## Installation

With [npm](https://www.npmjs.org/package/printj):

```bash
$ npm install printj
```

In the browser:

```html
<script src="printj.js"></script>
```

The browser exposes a variable `PRINTJ`

When installed globally, npm installs a script `printj` that renders the format
string with the given arguments.  Running the script with `-h` displays help.

The script will manipulate `module.exports` if available (e.g. in a CommonJS
`require` context).  This is not always desirable.  To prevent the behavior,
define `DO_NOT_EXPORT_PRINTJ`

## Usage

In all cases, the relevant function takes a format and arguments to be rendered.

The return value is a JS string.

- `PRINTJ.sprintf(format, ...args)` assumes the arguments are passed directly

- `PRINTJ.vsprintf(format, argv)` assumes the arguments are passed in an array

For example:

```js
> // var PRINTJ = require('printj');       // uncomment this line if in node
> var sprintf = PRINTJ.sprintf, vsprintf = PRINTJ.vsprintf;
> sprintf("Hello %s", "SheetJS")           // 'Hello SheetJS'
> sprintf("%d + %d = %d", 2,3,2+3)         // '2 + 3 = 5'
> vsprintf("%d + %d = %d", [2,3,5])        // '2 + 3 = 5'
> sprintf("%1$02hhx %1$u %1$i %1$o", -69)  // 'bb 4294967227 -69 37777777673'
```

The command line script takes a format and arguments:

```
usage: printj [options] <format> [args...]

Options:
    -h, --help      output usage information
    -d, --dump      print debug information about format string

Arguments are treated as strings unless prefaced by a type indicator:
    n:<integer>     call parseInt (ex. n:3 -> 3)
    f:<float>       call parseFloat (ex. f:3.1 -> 3.1)
    b:<boolean>     false when lowercase value is "FALSE" or "0", else true
    s:<string>      interpret as string (ex. s:n:3 -> "n:3")
    j:<JSON>        interpret as an object using JSON.parse
    e:<JS>          evaluate argument (ex. e:1+1 -> 2, e:"1"+1 -> "11")

samples:
    $ printj '|%02hhx%d|' n:50 e:0x7B                # |32123|
    $ printj '|%2$d + %3$d is %1$d|' e:1+2 n:1 n:2   # |1 + 2 is 3|
    $ printj '|%s is %s|' s:1+2 e:1+2                # |1+2 is 3|
    $ printj '|%c %c|' s:69 n:69                     # |6 E|
```

## Testing

`make test` will run the nodejs-based test.

`make stress` will run a larger test encompassing every possible conversion.  It
requires access to a C compiler.

## License

Please consult the attached LICENSE file for details.  All rights not explicitly
granted by the Apache 2.0 license are reserved by the Original Author.

## Badges

[![Build Status](https://saucelabs.com/browser-matrix/printj.svg)](https://saucelabs.com/u/printj)

[![Build Status](https://travis-ci.org/SheetJS/printj.svg?branch=master)](https://travis-ci.org/SheetJS/printj)

[![Coverage Status](http://img.shields.io/coveralls/SheetJS/printj/master.svg)](https://coveralls.io/r/SheetJS/printj?branch=master)

[![NPM Downloads](https://img.shields.io/npm/dt/printj.svg)](https://npmjs.org/package/printj)

[![Dependencies Status](https://david-dm.org/sheetjs/printj/status.svg)](https://david-dm.org/sheetjs/printj)

[![ghit.me](https://ghit.me/badge.svg?repo=sheetjs/printj)](https://ghit.me/repo/sheetjs/printj)

[![Analytics](https://ga-beacon.appspot.com/UA-36810333-1/SheetJS/printj?pixel)](https://github.com/SheetJS/printj)

# printf format string specification

The `printf` family of functions attempt to generate and output a string of
characters from a series of arguments, following a user-supplied "format string"
specification.  The format string contains normal characters that are written to
the output string as well as specifiers that describe which parameter to insert
and how to render the parameter.  This specification describes how a conformant
implementation should process the format string and generate an output string.
Any discrepancies between this document and the reference implementation are
considered bugs in the implementation.

### Original C Interface

Every function in the `printf` family follows the same logic to generate strings
but have different interfaces reflecting different input and output behaviors.
Some functions have wide variants that use wide `wchar_t *` strings rather than
normal C `char *`.  The following variants are required by the POSIX spec:

|  function  | max length |  output destination   | vintage |  wide ver  |
|------------|------------|-----------------------|---------|------------|
| `printf`   | unbounded  | standard output       | K&R     | `wprintf`  |
| `fprintf`  | unbounded  | stream (`FILE *`)     | K&R     | `fwprintf` |
| `sprintf`  | unbounded  | string (`char *`)     | K&R     | `swprintf` |
| `snprintf` | parameter  | string (`char *`)     | C99     |            |
| `dprintf`  | unbounded  | POSIX file descriptor | POSIX   |            |

Each function has a dual function, whose name begins with `v`, that accepts the
parameters as a `va_list` rather than formal parameters.  In all cases, they
return the number of characters written or a negative value to indicate error:

```C
int   sprintf(char *ostr, const char *fmt, ...);
int  vsprintf(char *ostr, const char *fmt, va_list arg_list);

int  swprintf(wchar_t *ostr, const wchar_t *fmt, ...);
int vswprintf(wchar_t *ostr, const wchar_t *fmt, va_list arg_list);
```

### JS and C strings

C "strings" are really just arrays of numbers.  An external code page (such as
ASCII) maps those numbers to characters.  K&R defines two types of strings:
basic character set strings (`char *`) and extended character set strings
(`wchar_t *`). In contrast, JS has a true string value type.

Unlike in C, JS strings do not treat the null character as an end-of-string
marker.  As a result, characters beyond the first null character will be used.

The JS equivalent of a C extended string would be an array of the individual
character codes.  The C basic string equivalent would involve specifying a code
page and mapping back.  The `codepage` JS library supports common codepages.

While capturing the essence of C strings, using arrays of character codes is not
idiomatic JS.  Few developers leverage this and the downsides far exceed the
benefits of a more direct translation.  The effect can be feigned, as shown in
the `js2c` code sample at the end of the document.

### JS Interface

In the absence of a standard output or even a standard concept of a stream, the
non-string outputs are irrelevant.  Similarly there is no JS analogue of wide
characters.  While useful, lack of direct memory management obviates `snprintf`.
This implementation exports the remaining functions, `sprintf` and `vsprintf`.

Instead of replicating the original C signature and `errno`, functions directly
return the output string and throw Errors:

```typescript
function  sprintf(fmt:string, ...args):string;
function vsprintf(fmt:string, args:Array<any>):string;
```

The C functions return the number of characters written to the string, which is
directly accessible in JS via the `length` property.  A direct replica of the
various string functions are included at the end of the document.

## Specifier heritage and regular expression

Note: The regular expressions follow perl `/x` style.  Whitespace characters
outside of character classes are ignored.  `#` is a comment character and every
character until the end of the line is ignored.  To convert to a standard regex:

```js
regex_string.replace(/#.*$/gm,"").replace(/^\s*/gm,"").replace(/\s*\n/gm,"");
```

Based on K&R, conversions originally followed the format:

 - required: leading `%`
 - optional: `-` (POSIX refers to this as the "flags")
 - optional: positive number or `*` (POSIX "width")
 - optional: period followed by positive number or `*` (POSIX "precision")
 - optional: an `h` or `l` to indicate size of data (POSIX "length")
 - required: character describing output behavior (POSIX "conversion specifier")

This is captured by the regular expression:

```perl
/%(?:
    ([-])?                             # flags (only minus sign)
    (\d+|\*)?                          # width
    (?:\.(\d+|\*))?                    # period + precision
    ([hl])?                            # length
    ([dioxXucsfeEgGp%])                # conversion specifier
)/x
```

Various implementations of `printf` have added different functionality.

ANSI standards up through C99:

 - more flags `"+"` `" "` `"0"` `"#"`
 - more lengths `"L"` `"hh"` `"ll"` `"j"` `"z"` `"t"`
 - more conversions `"F"` `"a"` `"A"` `"n"`

The POSIX specification of `printf` added:

 - positional parameters to identify argument indices
 - more flags `"'"`
 - more conversions `"C"` `"S"`
 - clarifications regarding corner cases and "undefined behavior"

BSD implementations added:

 - more lengths `"q"`
 - more conversions `"D"` `"U"` `"O"`

glibc (GNU) added:

 - more lengths `"Z"`
 - more conversions `"m"`

Windows C Runtime (CRT) added:

 - more lengths `"I"` `"I32"` `"I64"` `"w"`

glibc and CRT both added `Z`. glibc uses `Z` for the length `size_t`. CRT uses
`Z` as a conversion for length-prefixed strings.  This implementation takes the
former approach, handling `Z` in the same way as `z`.

BSD and IBM C library both added `D`.  BSD uses `D` as a conversion, namely as
an alias of `ld`.  IBM uses `D` for the length for `_Decimal64`, a decimal
floating point type, in accordance with ISO/IEC TR 24732.  This implementation
takes the former approach.

This implementation also adds new conversions:

 - `"b"` and `"B"` for binary (base-2) integer renderings
 - `"y"` and `"Y"` for true/false and yes/no Boolean conversions
 - `"J"` for JSON
 - `"T"` and `"V"` for JS typeof and valueOf inspection

Combining the various extensions yields the following regular expression:

```perl
/%(?:
    %|                                  # literal %% (flags etc prohibited)
    ([1-9]\d*\$)?                       # positional parameter
    ([-+ 0\x23\x27]*)?                  # flags
    ([1-9]\d*|\*(?:[1-9]\d*\$)?)?       # width
    (?:\.(\d+|\*(?:[1-9]\d*\$)?))?      # precision
    (hh?|ll?|[LzjtqZIw])?               # length
    ([diouxXfFeEgGaAcCsSpnDUOmbByYJVT]) # conversion specifier
)/x
```
This implementation explicitly does not support certain non-standard extensions:

 - AltiVec vector length extensions (`v` with `h`/`l`/`ll`):
 - CRT fixed width lengths `I32` and `I64`

## Conversion Specifier Quick Reference Table

|  C  |   Type   | Summary                                                     |
|-----|:--------:|-------------------------------------------------------------|
| `a` | floating | base-2 exp form w/ hex mantissa and dec exponent, lowercase |
| `A` | floating | base-2 exp form w/ hex mantissa and dec exponent, uppercase |
| `b` | extended | cast to C `unsigned int`,   standard form binary            |
| `B` | extended | cast to C `unsigned long`,  standard form binary            |
| `c` |   text   | print `latin-1` char from number OR first char of string    |
| `C` |   text   | print `UCS-2`   char from number OR first char of string    |
| `d` | integral | cast to C `int`,   standard form decimal                    |
| `D` | integral | cast to C `long`,  standard form decimal                    |
| `e` | floating | base-10 exp form w/dec mantissa and dec exponent, lowercase |
| `E` | floating | base-10 exp form w/dec mantissa and dec exponent, uppercase |
| `f` | floating | base-10 decimal form, lowercase extended values             |
| `F` | floating | base-10 decimal form, uppercase extended values             |
| `g` | floating | print using `e` or `f` conversion based on value/precision  |
| `G` | floating | print using `E` or `F` conversion based on value/precision  |
| `i` | integral | cast to C `int`,   standard form decimal (alias of `d`)     |
| `J` | extended | prints objects using JSON or `util.inspect`                 |
| `m` |   misc   | prints info about Error objects (JS equivalent of `errno`)  |
| `n` |   misc   | do not print! stores number of chars written to arg `.len`  |
| `o` | integral | cast to C `unsigned int`,   standard form octal             |
| `O` | integral | cast to C `unsigned long`,  standard form octal             |
| `p` |   misc   | print `"l"` field of object (fake pointer)                  |
| `s` |   text   | print string argument                                       |
| `S` |   text   | print string argument (alias of `"s"`)                      |
| `T` | extended | print type information (`typeof` or `Object toString`)      |
| `u` | integral | cast to C `unsigned int`,   standard form decimal           |
| `U` | integral | cast to C `unsigned long`,  standard form decimal           |
| `V` | extended | print primitive value (`valueOf`)                           |
| `x` | integral | cast to C `unsigned int`,   standard form hex, lowercase    |
| `X` | integral | cast to C `unsigned long`,  standard form hex, uppercase    |
| `y` | extended | prints `true`/`false` or `yes`/`no` based on Boolean value  |
| `Y` | extended | prints `TRUE`/`FALSE` or `YES`/`NO` based on Boolean value  |
| `%` |   misc   | print the literal `%` character                             |

## Parameter Selection

The default behavior is to consume arguments in order:

```C
printf("Count to 3: %d %d %d", 1, 2, 3); // Count to 3: 1 2 3
```

POSIX `printf` permits explicit argument selection, bypassing the standard
behavior of using the arguments in order.  To select the `n`-th argument, use
`n$` immediately after the `%` token to select an argument for the conversion:

```C
printf("%d %d %d",       1, 2, 3);        // 1 2 3 (implicit order 1, 2, 3 )
printf("%1$s %2$s %3$s", "a", "b", "c");  // a b c (explicit order 1, 2, 3 )
printf("%1$s %3$s %2$s", "a", "b", "c");  // a c b (explicit order 1, 3, 2 )
```

The POSIX standard asserts that mixing positional and non-positional conversions
is undefined behavior.  This implementation handles mixing by tracking the index
for non-positional conversions:

```C
printf("%s %4$s %s %5$s %s", "a", "b", "c", "d", "e"); // a d b e c
```

The POSIX standard requires that if an argument is used in the format, every
preceding argument must be used.  This implementation relaxes that requirement:

```C
printf("%3$s", "a", "b", "c"); // c (technically invalid since "a"/"b" unused)
```

## Dynamic Specifiers

The width and precision specifiers may include the dynamic specifier `*` which
instructs the engine to read the next argument (assumed to be an integer).  Just
as with the positional parameter, `idx$` immediately after the `*` token selects
the numeric argument.

For example:

```C
printf("|%5s|", "sheetjs");               // |sheetjs|    (width = 5)
printf("|%*s|", 5, "sheetjs");            // |sheetjs|    (width first argument)
printf("|%2$*1$s|", 5, "sheetjs", 10);    // |sheetjs|    (width is argument #1)

printf("|%10s|", "sheetjs");              // |   sheetjs| (width = 10)
printf("|%2$*3$s|", 5, "sheetjs", 10);    // |   sheetjs| (width is argument #3)
```

Arguments are generally consumed in order as presented in the format string:

```C
printf("|%s|", val);
printf("|%*s|", width, val);
printf("|%.*s|", prec, val);
printf("|%*.*s|", width, prec, val);
printf("|%0*.*d|", 4, 2, 1);  // |  01| width=4 prec=2 value=1
```

Positional arguments can be applied to width and precision:

```C
printf("|%*.*d|", width, prec, val);
printf("|%2$0*3$.*1$d|", prec, val, width);
printf("|%0*.*d|", 4, 2, 1);        // |  01| width=4 prec=2 value=1 flags='0'
printf("|%1$0*3$.*2$d|", 1, 2, 4);  // |  01| width=4 prec=2 value=1 flags='0'
```

A negative width is interpreted as the `-` flag with a positive width:

```C
printf("|%*.*d|",   4, 2, 1);        // |  01| width=4 prec=2 value=1 flags=''
printf("|%-*.*d|",  4, 2, 1);        // |01  | width=4 prec=2 value=1 flags='-'
printf("|%*.*d|",  -4, 2, 1);        // |01  | width=4 prec=2 value=1 flags='-'
printf("|%