"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergePathsAndComponents = void 0;
const atlassian_openapi_1 = require("atlassian-openapi");
const reference_walker_1 = require("./reference-walker");
const lodash_1 = __importDefault(require("lodash"));
const operation_selection_1 = require("./operation-selection");
const component_equivalence_1 = require("./component-equivalence");
const dispute_1 = require("./dispute");
function removeFromStart(input, trim) {
    if (input.startsWith(trim)) {
        return input.substring(trim.length);
    }
    return input;
}
function processComponents(results, components, areEqual, dispute, addModifiedReference) {
    for (const key in components) {
        /* eslint-disable-next-line no-prototype-builtins */
        if (components.hasOwnProperty(key)) {
            const component = components[key];
            const modifiedKey = dispute_1.applyDispute(dispute, key, 'undisputed');
            if (modifiedKey !== key) {
                addModifiedReference(key, modifiedKey);
            }
            if (results[modifiedKey] === undefined || areEqual(results[modifiedKey], component)) {
                // Add the schema
                results[modifiedKey] = component;
            }
            else {
                // Distnguish the name and then add the element
                let schemaPlaced = false;
                // Try and use the dispute prefix first
                if (dispute !== undefined) {
                    const preferredSchemaKey = dispute_1.applyDispute(dispute, key, 'disputed');
                    if (results[preferredSchemaKey] === undefined || areEqual(results[preferredSchemaKey], component)) {
                        results[preferredSchemaKey] = component;
                        addModifiedReference(key, preferredSchemaKey);
                        schemaPlaced = true;
                    }
                }
                // Incrementally find the right prefix
                for (let antiConflict = 1; schemaPlaced === false && antiConflict < 1000; antiConflict++) {
                    const trySchemaKey = `${key}${antiConflict}`;
                    if (results[trySchemaKey] === undefined) {
                        results[trySchemaKey] = component;
                        addModifiedReference(key, trySchemaKey);
                        schemaPlaced = true;
                    }
                }
                // In the unlikely event that we can